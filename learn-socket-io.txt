# 🚀 Socket.IO: Complete Guide with Real Examples

## 🌟 Basic Socket.IO Setup

### 1. Client-Side Setup (Frontend)
```typescript
// Import Socket.IO client
import { io } from 'socket.io-client';

// Create socket connection
const socket = io('http://your-server.com', {
  withCredentials: true,  // For sending cookies
  autoConnect: true,      // Automatically connect
});

// Connect to socket
socket.connect();

// Disconnect from socket
socket.disconnect();
```

### 2. Server-Side Setup (Backend)
```typescript
// Import Socket.IO server
import { Server } from 'socket.io';

// Create Socket.IO instance
const io = new Server(server, {
  cors: {
    origin: "http://your-client.com",
    methods: ["GET", "POST"],
    credentials: true
  }
});

// Handle connection
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
});
```

## 🔌 Socket.IO Events in Your Project

### 1. Chat Events
```typescript
// Sending a message
socket.emit('send_message', {
  chatId: '123',
  content: 'Hello!',
  senderId: 'user1'
});

// Receiving a message
socket.on('receive_message', (message) => {
  console.log('New message:', message);
  // Update UI with new message
});

// Message delivery confirmation
socket.on('message_sent', (data) => {
  console.log('Message delivered:', data);
});

// Message error
socket.on('message_error', (error) => {
  console.error('Message failed:', error);
});
```

### 2. Typing Indicators
```typescript
// Start typing
socket.emit('typing', {
  chatId: '123',
  userId: 'user1'
});

// Stop typing
socket.emit('stop_typing', {
  chatId: '123',
  userId: 'user1'
});

// Listen for typing events
socket.on('user_typing', ({ chatId, userId }) => {
  if (activeChat?.id === chatId && userId !== currentUser?.id) {
    setIsTyping(true);
  }
});

socket.on('user_stop_typing', ({ chatId, userId }) => {
  if (activeChat?.id === chatId && userId !== currentUser?.id) {
    setIsTyping(false);
  }
});
```

### 3. Video Call Events
```typescript
// Request a video call
socket.emit('video-call-request', {
  roomId: activeChat.id,
  callerId: currentUser.id,
  callerName: currentUser.name
});

// Respond to video call
socket.emit('video-call-response', {
  roomId: incomingCall.roomId,
  receiverId: currentUser.id,
  accepted: true // or false
});

// Listen for incoming calls
socket.on('incoming-video-call', ({ roomId, callerId, callerName }) => {
  setIncomingCall({ roomId, callerId, callerName });
});

// Listen for call responses
socket.on('video-call-accepted', ({ roomId }) => {
  router.push(`/video-chat/${roomId}`);
});

socket.on('video-call-rejected', () => {
  alert('Call was rejected');
});
```

## 🏗️ Room Management

### 1. Joining and Leaving Rooms
```typescript
// Join a room
socket.emit('join_chat', { chatId: '123' });

// Leave a room
socket.emit('leave_chat', { chatId: '123' });

// Server-side room handling
io.on('connection', (socket) => {
  socket.on('join_chat', ({ chatId }) => {
    socket.join(chatId);
  });

  socket.on('leave_chat', ({ chatId }) => {
    socket.leave(chatId);
  });
});
```

### 2. Broadcasting to Rooms
```typescript
// Server-side broadcasting
io.to('roomId').emit('event', data);        // To all in room
socket.to('roomId').emit('event', data);    // To all except sender
socket.broadcast.emit('event', data);       // To all except sender
io.emit('event', data);                     // To all connected
```

## 🛠️ Useful Socket.IO Patterns

### 1. Connection State Management
```typescript
// Check connection status
const isConnected = socket.connected;

// Listen for connection events
socket.on('connect', () => {
  console.log('Connected to server');
});

socket.on('disconnect', () => {
  console.log('Disconnected from server');
});

socket.on('connect_error', (error) => {
  console.error('Connection error:', error);
});
```

### 2. Error Handling
```typescript
// Client-side error handling
socket.on('error', (error) => {
  console.error('Socket error:', error);
  // Show user-friendly error message
});

// Server-side error handling
socket.on('error', (error) => {
  logger.error('Socket error:', error);
  socket.emit('error', { message: 'An error occurred' });
});
```

### 3. Cleanup and Resource Management
```typescript
// Clean up event listeners
useEffect(() => {
  if (!socket) return;

  // Add event listeners
  socket.on('event1', handler1);
  socket.on('event2', handler2);

  // Cleanup function
  return () => {
    socket.off('event1', handler1);
    socket.off('event2', handler2);
  };
}, [socket]);
```

## 🎯 Best Practices in Your Project

### 1. Event Naming Convention
```typescript
// Use consistent naming
- video-call-request
- video-call-response
- incoming-video-call
- video-call-accepted
- video-call-rejected
```

### 2. Data Structure
```typescript
// Consistent data structure for events
interface VideoCallRequest {
  roomId: string;
  callerId: string;
  callerName: string;
}

interface VideoCallResponse {
  roomId: string;
  receiverId: string;
  accepted: boolean;
}
```

### 3. Error Recovery
```typescript
// Reconnect on error
socket.on('connect_error', () => {
  setTimeout(() => {
    socket.connect();
  }, 1000);
});

// Handle reconnection
socket.on('reconnect', (attemptNumber) => {
  console.log('Reconnected after', attemptNumber, 'attempts');
});
```

## 📚 Common Use Cases in Your Project

### 1. Real-time Chat
```typescript
// Send message
const sendMessage = (content: string) => {
  socket.emit('send_message', {
    chatId: activeChat.id,
    content,
    senderId: currentUser.id
  });
};

// Receive messages
useEffect(() => {
  socket.on('receive_message', (message) => {
    if (message.chatId === activeChat.id) {
      setMessages(prev => [...prev, message]);
    }
  });
}, [socket, activeChat]);
```

### 2. Video Call Signaling
```typescript
// Handle incoming calls
useEffect(() => {
  socket.on('incoming-video-call', ({ roomId, callerId, callerName }) => {
    setIncomingCall({ roomId, callerId, callerName });
  });
}, [socket]);

// Handle call responses
const handleAcceptCall = () => {
  socket.emit('video-call-response', {
    roomId: incomingCall.roomId,
    receiverId: currentUser.id,
    accepted: true
  });
};
```

## 🎉 Conclusion

Socket.IO is a powerful tool for real-time communication in your application. The patterns and examples shown here are directly from your project and demonstrate best practices for:

1. Real-time chat
2. Video call signaling
3. Room management
4. Error handling
5. Resource cleanup

Remember to:
- Use consistent event naming
- Handle connection states
- Clean up event listeners
- Implement error recovery
- Use TypeScript for type safety

Happy coding! 🚀 